<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Calder Mobile</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #f5f5f0;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.scale(dpr, dpr);
    }
    resize();
    window.addEventListener('resize', resize);

    const W = () => window.innerWidth;
    const H = () => window.innerHeight;

    // BANK VAULT physics - glacially slow, immense inertia
    const GRAVITY = 0.003;  // Barely any gravity = ultra slow swing
    const DAMPING = 0.9992;  // Like moving through honey
    const WIND_SENSITIVITY = 0.0005; // Almost completely ignores mouse

    let wind = { x: 0, y: 0 };
    let lastMouse = { x: W() / 2, y: H() / 2 };

    // Calder colors
    const COLORS = ['#E53935', '#FDD835', '#1E88E5', '#212121', '#FAFAFA', '#FF7043'];

    class Shape {
      constructor(type, color, size) {
        this.type = type;
        this.color = color;
        this.size = size;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationVel = 0;
      }

      draw(ctx, x, y) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.shadowColor = 'rgba(0,0,0,0.15)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 8;

        ctx.beginPath();
        const s = this.size;

        if (this.type === 'circle') {
          ctx.arc(0, 0, s, 0, Math.PI * 2);
        } else if (this.type === 'oval') {
          ctx.ellipse(0, 0, s * 0.55, s, 0, 0, Math.PI * 2);
        } else if (this.type === 'leaf') {
          ctx.moveTo(0, -s);
          ctx.bezierCurveTo(s * 1.2, -s * 0.4, s * 1.1, s * 0.6, 0, s);
          ctx.bezierCurveTo(-s * 0.8, s * 0.4, -s * 0.9, -s * 0.5, 0, -s);
        } else if (this.type === 'boomerang') {
          ctx.moveTo(-s * 1.2, -s * 0.2);
          ctx.quadraticCurveTo(-s * 0.3, -s * 0.9, s * 0.8, -s * 0.5);
          ctx.quadraticCurveTo(s * 1.1, -s * 0.1, s * 0.9, s * 0.3);
          ctx.quadraticCurveTo(s * 0.2, s * 0.5, -s * 0.5, s * 0.2);
          ctx.quadraticCurveTo(-s * 1.0, 0, -s * 1.2, -s * 0.2);
        } else if (this.type === 'blob') {
          ctx.moveTo(0, -s);
          ctx.bezierCurveTo(s * 1.3, -s * 0.6, s * 1.1, s * 0.7, 0, s * 1.1);
          ctx.bezierCurveTo(-s * 0.9, s * 0.7, -s * 1.2, -s * 0.4, 0, -s);
        }

        ctx.fill();

        if (this.color === '#FAFAFA') {
          ctx.strokeStyle = '#ccc';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.restore();
      }

      update(force) {
        this.rotationVel += force * 0.0003; // Very slow rotation
        this.rotationVel *= 0.995;
        this.rotation += this.rotationVel;
      }
    }

    class Pendulum {
      constructor(length, mass = 1) {
        this.length = length;
        this.mass = mass;
        this.angle = 0;
        this.angleVel = 0;
        this.shape = null;
        this.children = [];
        this.x = 0;
        this.y = 0;
      }

      update(parentX, parentY) {
        this.x = parentX + Math.sin(this.angle) * this.length;
        this.y = parentY + Math.cos(this.angle) * this.length;

        // Heavy pendulum physics
        const gravity = GRAVITY * this.mass / Math.sqrt(this.length);
        const windForce = wind.x * WIND_SENSITIVITY / this.mass;

        this.angleVel += -gravity * Math.sin(this.angle) + windForce * Math.cos(this.angle);
        this.angleVel *= DAMPING;
        this.angle += this.angleVel;

        if (this.shape) {
          this.shape.update(this.angleVel * this.length);
        }

        this.children.forEach(child => child.update(this.x, this.y));
      }

      draw(ctx, parentX, parentY) {
        // Draw curved wire
        ctx.beginPath();
        ctx.moveTo(parentX, parentY);

        // Graceful curve
        const midX = (parentX + this.x) / 2;
        const midY = (parentY + this.y) / 2 - this.length * 0.08;
        ctx.quadraticCurveTo(midX, midY, this.x, this.y);

        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2;
        ctx.stroke();

        if (this.shape) {
          this.shape.draw(ctx, this.x, this.y);
        }

        this.children.forEach(child => child.draw(ctx, this.x, this.y));
      }
    }

    class Bar {
      constructor(leftLen, rightLen, sag = 0.12) {
        this.leftLen = leftLen;
        this.rightLen = rightLen;
        this.sag = sag; // How much the wire curves
        this.angle = 0;
        this.angleVel = 0;
        this.leftChildren = [];
        this.rightChildren = [];
        this.x = 0;
        this.y = 0;
      }

      getLeftPoint() {
        return {
          x: this.x - Math.cos(this.angle) * this.leftLen,
          y: this.y + Math.sin(this.angle) * this.leftLen * 0.3
        };
      }

      getRightPoint() {
        return {
          x: this.x + Math.cos(this.angle) * this.rightLen,
          y: this.y - Math.sin(this.angle) * this.rightLen * 0.3
        };
      }

      getMass(children) {
        let m = 0;
        children.forEach(c => {
          if (c instanceof Pendulum) {
            m += c.mass;
            m += this.getMass(c.children);
          } else if (c instanceof Bar) {
            m += this.getMass(c.leftChildren) + this.getMass(c.rightChildren);
          }
        });
        return m;
      }

      update(parentX, parentY) {
        this.x = parentX;
        this.y = parentY;

        const leftMass = this.getMass(this.leftChildren);
        const rightMass = this.getMass(this.rightChildren);
        const torque = (rightMass * this.rightLen - leftMass * this.leftLen) * 0.000008;
        const windTorque = wind.x * 0.00003;

        this.angleVel += torque + windTorque - this.angle * 0.002;
        this.angleVel *= DAMPING;
        this.angle += this.angleVel;
        this.angle = Math.max(-0.25, Math.min(0.25, this.angle));

        const left = this.getLeftPoint();
        const right = this.getRightPoint();

        this.leftChildren.forEach(child => child.update(left.x, left.y));
        this.rightChildren.forEach(child => child.update(right.x, right.y));
      }

      draw(ctx, parentX, parentY) {
        const left = this.getLeftPoint();
        const right = this.getRightPoint();

        // Curved connection from parent - slight outward bow
        ctx.beginPath();
        ctx.moveTo(parentX, parentY);
        ctx.lineTo(this.x, this.y);
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2;
        ctx.stroke();

        // CURVED bar - graceful DOWNWARD sag (like real wire under gravity)
        ctx.beginPath();
        ctx.moveTo(left.x, left.y);

        // Control point BELOW the midpoint = sag DOWN
        const midX = (left.x + right.x) / 2;
        const midY = (left.y + right.y) / 2;
        const sagAmount = (this.leftLen + this.rightLen) * this.sag;
        const cpX = midX;
        const cpY = midY + sagAmount; // BELOW the line = hangs down

        ctx.quadraticCurveTo(cpX, cpY, right.x, right.y);
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Pivot point
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#1a1a1a';
        ctx.fill();

        this.leftChildren.forEach(child => child.draw(ctx, left.x, left.y));
        this.rightChildren.forEach(child => child.draw(ctx, right.x, right.y));
      }
    }

    // Build a LARGE mobile
    function createMobile() {
      const scale = Math.min(W(), H()) / 900; // Scale to viewport
      const S = (v) => v * scale;

      const root = new Pendulum(S(50), 0.5);

      // Main bar - spans most of the screen
      const mainBar = new Bar(S(320), S(380), 0.06);
      root.children.push(mainBar);

      // === FAR LEFT ===
      const farLeftPend = new Pendulum(S(120), 3);
      farLeftPend.shape = new Shape('blob', COLORS[0], S(55));
      mainBar.leftChildren.push(farLeftPend);

      // === LEFT BRANCH ===
      const leftBar = new Bar(S(140), S(180), 0.1);
      const leftBarMount = new Pendulum(S(80), 1);
      leftBarMount.children.push(leftBar);
      mainBar.leftChildren.push(leftBarMount);

      const ll1 = new Pendulum(S(150), 2.5);
      ll1.shape = new Shape('circle', COLORS[1], S(45));
      leftBar.leftChildren.push(ll1);

      const lr1 = new Pendulum(S(100), 2);
      lr1.shape = new Shape('leaf', COLORS[2], S(50));
      leftBar.rightChildren.push(lr1);

      // Sub-branch on left
      const leftSubBar = new Bar(S(80), S(100), 0.15);
      const leftSubMount = new Pendulum(S(70), 0.8);
      leftSubMount.children.push(leftSubBar);
      leftBar.rightChildren.push(leftSubMount);

      const lsl = new Pendulum(S(90), 1.8);
      lsl.shape = new Shape('boomerang', COLORS[3], S(40));
      leftSubBar.leftChildren.push(lsl);

      const lsr = new Pendulum(S(110), 2);
      lsr.shape = new Shape('oval', COLORS[0], S(38));
      leftSubBar.rightChildren.push(lsr);

      // === CENTER DROP ===
      const centerMount = new Pendulum(S(160), 0.6);
      const centerBar = new Bar(S(120), S(150), 0.12);
      centerMount.children.push(centerBar);
      mainBar.leftChildren.push(centerMount);

      const cl = new Pendulum(S(130), 2.2);
      cl.shape = new Shape('circle', COLORS[3], S(42));
      centerBar.leftChildren.push(cl);

      const cr = new Pendulum(S(100), 1.8);
      cr.shape = new Shape('leaf', COLORS[5], S(48));
      centerBar.rightChildren.push(cr);

      // Deep center branch
      const deepBar = new Bar(S(70), S(90), 0.18);
      const deepMount = new Pendulum(S(90), 0.5);
      deepMount.children.push(deepBar);
      centerBar.rightChildren.push(deepMount);

      const dl = new Pendulum(S(80), 1.5);
      dl.shape = new Shape('boomerang', COLORS[1], S(35));
      deepBar.leftChildren.push(dl);

      const dr = new Pendulum(S(100), 1.8);
      dr.shape = new Shape('blob', COLORS[2], S(40));
      deepBar.rightChildren.push(dr);

      // === RIGHT BRANCH ===
      const rightBar = new Bar(S(160), S(200), 0.08);
      const rightMount = new Pendulum(S(60), 0.8);
      rightMount.children.push(rightBar);
      mainBar.rightChildren.push(rightMount);

      const rl = new Pendulum(S(140), 2.8);
      rl.shape = new Shape('oval', COLORS[3], S(50));
      rightBar.leftChildren.push(rl);

      const rr = new Pendulum(S(90), 2);
      rr.shape = new Shape('circle', COLORS[4], S(38));
      rightBar.rightChildren.push(rr);

      // Right sub-branch
      const rightSubBar = new Bar(S(100), S(130), 0.14);
      const rightSubMount = new Pendulum(S(80), 0.6);
      rightSubMount.children.push(rightSubBar);
      rightBar.rightChildren.push(rightSubMount);

      const rsl = new Pendulum(S(100), 1.6);
      rsl.shape = new Shape('leaf', COLORS[2], S(42));
      rightSubBar.leftChildren.push(rsl);

      const rsr = new Pendulum(S(120), 2);
      rsr.shape = new Shape('boomerang', COLORS[0], S(45));
      rightSubBar.rightChildren.push(rsr);

      // === FAR RIGHT ===
      const farRightPend = new Pendulum(S(100), 3.5);
      farRightPend.shape = new Shape('blob', COLORS[1], S(60));
      mainBar.rightChildren.push(farRightPend);

      return root;
    }

    let mobile = createMobile();

    window.addEventListener('resize', () => {
      resize();
      mobile = createMobile();
    });

    // Mouse - very subtle influence
    let mouseDown = false;
    canvas.addEventListener('mousedown', () => mouseDown = true);
    canvas.addEventListener('mouseup', () => mouseDown = false);

    canvas.addEventListener('mousemove', (e) => {
      const dx = e.clientX - lastMouse.x;

      // Only respond if mouse is pressed AND moving significantly
      if (mouseDown && Math.abs(dx) > 30) {
        wind.x += dx * 0.02; // Very subtle influence
      }

      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
    });

    // Click for barely perceptible push
    canvas.addEventListener('click', (e) => {
      const direction = e.clientX > W() / 2 ? 1 : -1;
      wind.x += direction * 3; // Extremely subtle - bank vault mass
    });

    function animate() {
      ctx.clearRect(0, 0, W(), H());

      // Wind decays quickly - impulses don't linger
      wind.x *= 0.95;
      wind.y *= 0.95;

      const anchorX = W() / 2;
      const anchorY = H() * 0.08;

      // Anchor
      ctx.beginPath();
      ctx.arc(anchorX, anchorY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#1a1a1a';
      ctx.fill();

      mobile.update(anchorX, anchorY);
      mobile.draw(ctx, anchorX, anchorY);

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
